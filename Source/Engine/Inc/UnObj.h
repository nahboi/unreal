/*=============================================================================
	UnObj.h: Standard Unreal object definitions.
	Copyright 1997 Epic MegaGames, Inc. This software is a trade secret.

	Revision history:
		* Created by Tim Sweeney
=============================================================================*/

/*-----------------------------------------------------------------------------
	Forward declarations.
-----------------------------------------------------------------------------*/

// Foward declaration macro.
#define DECLARE_RES(ResClass) \
	class ResClass; \
	FArchive& operator<<( FArchive&, ResClass*& ); \

// Declare a database class.
#define DECLARE_DB_CLASS( TClass, TSuperClass, TDataType )\
	/* Special database specific */\
	typedef TDataType BaseDataType;\
	enum {StaticRecordSize = sizeof(BaseDataType)};\
	\
	INT Num() const { return GetNum(); } \
	INT Max() const { return GetMax(); } \
	/* Return the type-safe ith element of a database object */\
	BaseDataType& Element( int i )\
	{ \
		/* Element is only valid when an object is locked or is not swappable. */ \
		return ((BaseDataType *)GetData())[i]; \
	} \
	const BaseDataType& Element( int i ) const\
	{ \
		/* Element is only valid when an object is locked or is not swappable. */ \
		return ((BaseDataType *)GetData())[i]; \
	} \
	/* An a new item */ \
	INT AddItem( BaseDataType Item ) \
	{ \
		INT Index = Add(1); \
		Element(Index) = Item; \
		return Index; \
	} \
	/* Remove an item if it exists */ \
	void RemoveItem( BaseDataType Item ) \
	{ \
		for( INT i=Num()-1; i>=0; i-- ) \
			if( appMemcmp( &Element(i), &Item, sizeof(BaseDataType) )==0 ) \
				Remove( i ); \
	} \
	/* Find an item and return 1 if found, 0 if not */ \
	INT FindItem( BaseDataType Item, INT& Result ) const \
	{ \
		for( INT i=0; i<Num(); i++ ) \
			if( appMemcmp( &Element(i), &Item, sizeof(BaseDataType) )==0 ) \
				{ Result = i; return 1; } \
		return 0; \
	} \
	/* Add an item if it's not a duplicate of an existing item */ \
	INT AddUniqueItem( BaseDataType Item ) \
	{ \
		for( INT i=0; i<Num(); i++ ) \
			if( appMemcmp( &Element(i), &Item, sizeof(BaseDataType) )==0 ) \
				return i; \
		return AddItem( Item ); \
	} \
	/* Standard serialization routine, generated by IMPLEMENT_DB_CLASS macro. */\
	void SerializeData( FArchive& Ar );

// Implement a database class.
#define IMPLEMENT_DB_CLASS(ClassName) \
	/* Implement the object class */ \
	IMPLEMENT_CLASS(ClassName) \
	/* Automatic data serializer. */ \
	void ClassName::SerializeData(FArchive &Ar) \
	{ \
		INT i=-1; \
		guard(ClassName::SerializeData); \
		if( sizeof(BaseDataType)==1 ) Ar.Serialize(&Element(0),Num()); \
		else for( i=0; i<Num(); i++ ) Ar << Element(i); \
		unguardf(("(%s)",GetFullName())); \
	}

// All engine classes.
PREDECLARE_CLASS(UBitmap);
PREDECLARE_CLASS(UTexture);
PREDECLARE_CLASS(UFont);
PREDECLARE_CLASS(UPalette);
PREDECLARE_CLASS(USound);
PREDECLARE_CLASS(UMesh);
PREDECLARE_CLASS(UVector);
PREDECLARE_CLASS(UBspNodes);
PREDECLARE_CLASS(UPolys);
PREDECLARE_CLASS(UModel);
PREDECLARE_CLASS(ULevel);
PREDECLARE_CLASS(UPendingLevel);
PREDECLARE_CLASS(UViewport);
PREDECLARE_CLASS(UPlayer);
PREDECLARE_CLASS(UNetConnection);
PREDECLARE_CLASS(UVerts);
PREDECLARE_CLASS(UMeshMap);
PREDECLARE_CLASS(UBounds);
PREDECLARE_CLASS(UMusic);
PREDECLARE_CLASS(UPrimitive);
PREDECLARE_CLASS(UConsole);

// Other classes.
struct FTextureInfo;
class  AActor;
class  ABrush;
class  FScan;

/*----------------------------------------------------------------------------
	UDatabase.
----------------------------------------------------------------------------*/

class ENGINE_API UDatabase : public UObject
{
	DECLARE_ABSTRACT_CLASS(UDatabase,UObject,0)

	// Variables.
private:
	void* Data;
	INT DbNum, DbMax;
public:

	// UObject interface.
	void Serialize( FArchive& Ar );
	void Destroy();

	// UDatabase interface.
	virtual void SerializeData( FArchive& Ar )=0;
	virtual void Empty();
	virtual void Shrink();
	virtual INT Add( INT NumToAdd=1 );
	virtual void Remove( INT Index, INT Count=1 );
	virtual void* Realloc();
	virtual void ModifyAllItems();

	// UDatabase accessors.
	void ModifyItem( INT i )
	{
		check(i>=0 && i<GetMax());
		if( GUndo && (GetFlags() & RF_Transactional) )
			GUndo->NoteSingleChange( this, i );
	}
	virtual UBOOL IsValidIndex( INT i )
	{
		return i>=0 && i<DbNum;
	}
	INT GetNum() const
	{
		return DbNum;
	}
	INT GetMax() const
	{
		return DbMax;
	}
	void SetNum( INT NewNum )
	{
		DbNum = NewNum;
	}
	void SetMax( INT NewMax )
	{
		DbMax = NewMax;
	}
	void* GetData()
	{
		return Data;
	}
	const void* GetData() const
	{
		return Data;
	}
	void SetData( void* New )
	{
		Data=New;
	}
};

/*-----------------------------------------------------------------------------
	UBspNode.
-----------------------------------------------------------------------------*/

// Flags associated with a Bsp node.
enum EBspNodeFlags
{
	// Flags.
	NF_NotCsg			= 0x01, // Node is not a Csg splitter, i.e. is a transparent poly.
	NF_ShootThrough		= 0x02, // Can shoot through (for projectile solid ops).
	NF_NotVisBlocking   = 0x04, // Node does not block visibility, i.e. is an invisible collision hull.
	NF_PolyOccluded		= 0x08, // Node's poly was occluded on the previously-drawn frame.
	NF_BoxOccluded		= 0x10, // Node's bounding box was occluded.
	NF_BrightCorners	= 0x10, // Temporary.
	NF_IsNew 		 	= 0x20, // Editor: Node was newly-added.
	NF_IsFront     		= 0x40, // Filter operation bounding-sphere precomputed and guaranteed to be front.
	NF_IsBack      		= 0x80, // Guaranteed back.

	// Combinations of flags.
	NF_NeverMove		= 0, // Bsp cleanup must not move nodes with these tags.
};

//
// Identifies a unique convex volume in the world.
//
struct ENGINE_API FPointRegion
{
	// Variables.
	class AZoneInfo* Zone;			// Zone actor.
	INT				 iLeaf;			// Bsp leaf.
	BYTE             ZoneNumber;	// Zone number.

	// Constructors.
	FPointRegion()
	{}
	FPointRegion( class AZoneInfo* InLevel )
	:	Zone(InLevel), iLeaf(INDEX_NONE), ZoneNumber(0)
	{}
	FPointRegion( class AZoneInfo* InZone, INT InLeaf, BYTE InZoneNumber )
	:	Zone(InZone), iLeaf(InLeaf), ZoneNumber(InZoneNumber)
	{}
};

//
// FBspNode defines one node in the Bsp, including the front and back
// pointers and the polygon data itself.  A node may have 0 or 3 to (MAX_NODE_VERTICES-1)
// vertices. If the node has zero vertices, it's only used for splitting and
// doesn't contain a polygon (this happens in the editor).
//
// vNormal, vTextureU, vTextureV, and others are indices into the level's
// vector table.  iFront,iBack should be INDEX_NONE to indicate no children.
//
// If iPlane==INDEX_NONE, a node has no coplanars.  Otherwise iPlane
// is an index to a coplanar polygon in the Bsp.  All polygons that are iPlane
// children can only have iPlane children themselves, not fronts or backs.
//
class FBspNode // 64 bytes
{
public:
	enum {MAX_NODE_VERTICES=16};	// Max vertices in a Bsp node, pre clipping
	enum {MAX_FINAL_VERTICES=24};	// Max vertices in a Bsp node, post clipping
	enum {MANY_CHILDREN=8};			// A Bsp Node with this many children is occlusion-rejected carefully

	// Persistent information.
	FPlane			Plane;			// 16 Plane the node falls into (X, Y, Z, W).
	QWORD			ZoneMask;		// 8  Bit mask for all zones at or below this node (up to 64).
	INT				iVertPool;		// 4  Index of first vertex in vertex pool, =iTerrain if NumVertices==0 and NF_TerrainFront.
	INT				iSurf;			// 4  Index to surface information.
	union
	{
		struct
		{
			INT		iBack;			// 4  Index to node in front (in direction of Normal).
			INT		iFront;			// 4  Index to node in back  (opposite direction as Normal).
			INT		iPlane;			// 4  Index to next coplanar poly in coplanar list.
		};
		struct
		{
			INT		iChild[3];		// 12 Index representation of children.
		};
	};
	INT				iCollisionBound;// 4  Collision bound.
	INT				iRenderBound;	// 4  Rendering bound.
	BYTE			iZone[2];		// 2  Visibility zone in 1=front, 0=back.
	BYTE			NumVertices;	// 1  Number of vertices in node.
	BYTE			NodeFlags;		// 1  Node flags.

	// Valid in memory only.
	INT				iLeaf[2];		// 4  Leaf in back and front, INDEX_NONE=not a leaf.

	// Functions.
	UBOOL IsCsg( DWORD ExtraFlags=0 ) const
	{
		return (NumVertices>0) && !(NodeFlags & (NF_IsNew | NF_NotCsg | ExtraFlags));
	}
	UBOOL ChildOutside( INT iChild, UBOOL Outside, DWORD ExtraFlags=0 ) const
	{
		return iChild ? (Outside || IsCsg(ExtraFlags)) : (Outside && !IsCsg(ExtraFlags));
	}
	friend FArchive& operator<<( FArchive& Ar, FBspNode& N )
	{
		guard(FBspNode<<);
		Ar << N.Plane << N.ZoneMask << N.NodeFlags << AR_INDEX(N.iVertPool) << AR_INDEX(N.iSurf);
		Ar << AR_INDEX(N.iChild[0]) << AR_INDEX(N.iChild[1]) << AR_INDEX(N.iChild[2]);
		Ar << AR_INDEX(N.iCollisionBound) << AR_INDEX(N.iRenderBound);
		Ar << N.iZone[0] << N.iZone[1];
		Ar << N.NumVertices;
		Ar << N.iLeaf[0] << N.iLeaf[1];
		return Ar;
		unguard;
	}
};

//
// Properties of a zone.
//
class ENGINE_API FZoneProperties
{
public:
	// General zone properties.
	AZoneInfo*	ZoneActor;		// Optional actor defining the zone's property.
	FLOAT		LastRenderTime;	// Most recent level TimeSeconds when rendered.

	// Connectivity and visibility bit masks.
	QWORD		Connectivity;	// (Connect[i]&(1<<j))==1 if zone i is adjacent to zone j.
	QWORD		Visibility;		// (Connect[i]&(1<<j))==1 if zone i can see zone j.

	// Serializer.
	friend FArchive& operator<<( FArchive& Ar, FZoneProperties& P )
	{
		guard(FZoneProperties<<);
		return Ar << *(UObject**)&P.ZoneActor << P.Connectivity << P.Visibility;
		if( Ar.Ver() >= 56 )//oldver
			Ar << P.LastRenderTime;
		else
			P.LastRenderTime=0;
		unguard;
	}
};

//
// A database of Bsp nodes associated with a model.
//
class ENGINE_API UBspNodes : public UDatabase
{
	DECLARE_CLASS_WITHOUT_CONSTRUCT(UBspNodes,UDatabase,0)
	DECLARE_DB_CLASS(UBspNodes,UDatabase,FBspNode)

	enum {MAX_ZONES=64};				// Maximum zones in a Bsp, limited by QWORD bitmask size

	// Variables.
	INT				NumZones;
	FZoneProperties	Zones[MAX_ZONES];

	// Constructors.
	UBspNodes();

	// UObject interface.
	void Serialize(FArchive& Ar)
	{
		guard(UBspNodes::Serialize);
		UDatabase::Serialize(Ar);
		Ar << AR_INDEX(NumZones);
		for( INT i=0; i<NumZones; i++ )
			Ar << Zones[i];
		unguardobj;
	}
};

/*-----------------------------------------------------------------------------
	UBspLeaves.
-----------------------------------------------------------------------------*/

//
// Information about a convex volume.
//
class FLeaf
{
public:
	// Variables.
	INT iZone;          // The zone this convex volume is in.
	INT iPermeating;    // Lights permeating this volume considering shadowing.
	INT iVolumetric;    // Volumetric lights hitting this region, no shadowing.
	QWORD VisibleZones; // Bit mask of visible zones from this convex volume.

	// Functions.
	FLeaf()
	{}
	FLeaf( INT iInZone, INT InPermeating, INT InVolumetric, QWORD InVisibleZones )
	:	iZone(iInZone), iPermeating(InPermeating), iVolumetric(InVolumetric), VisibleZones(InVisibleZones)
	{}
	friend FArchive& operator<<( FArchive& Ar, FLeaf& L )
	{
		guard(FLeaf<<);
		return Ar << AR_INDEX(L.iZone) << AR_INDEX(L.iPermeating) << AR_INDEX(L.iVolumetric) << L.VisibleZones;
		unguard;
	}
};

/*-----------------------------------------------------------------------------
	UBspSurf.
-----------------------------------------------------------------------------*/

//
// One Bsp polygon.  Lists all of the properties associated with the
// polygon's plane.  Does not include a point list; the actual points
// are stored along with Bsp nodes, since several nodes which lie in the
// same plane may reference the same poly.
//
class FBspSurf
{
public:

	// Persistent info.
	UTexture*	Texture;	// 4 Texture map.
	DWORD		PolyFlags;  // 4 Polygon flags.
	INT			pBase;      // 4 Polygon & texture base point index (where U,V==0,0).
	INT			vNormal;    // 4 Index to polygon normal.
	INT			vTextureU;  // 4 Texture U-vector index.
	INT			vTextureV;  // 4 Texture V-vector index.
	INT			iLightMap;	// 4 Light mesh.
	INT			iBrushPoly; // 4 Editor brush polygon index.
	SWORD		PanU;		// 2 U-Panning value.
	SWORD		PanV;		// 2 V-Panning value.
	ABrush*		Actor;		// 4 Brush actor owning this Bsp surface.

	// Functions.
	friend FArchive& operator<< (FArchive &Ar, FBspSurf &Surf)
	{
		guard(FBspSurf<<);
		Ar << Surf.Texture;
		Ar << Surf.PolyFlags << AR_INDEX(Surf.pBase) << AR_INDEX(Surf.vNormal);
		Ar << AR_INDEX(Surf.vTextureU) << AR_INDEX(Surf.vTextureV);
		Ar << AR_INDEX(Surf.iLightMap) << AR_INDEX(Surf.iBrushPoly);
		Ar << Surf.PanU << Surf.PanV;
		Ar << *(UObject**)&Surf.Actor;
		return Ar;
		unguard;
	}
};

// Flags describing effects and properties of a Bsp polygon.
enum EPolyFlags
{
	// Regular in-game flags.
	PF_Invisible		= 0x00000001,	// Poly is invisible.
	PF_Masked			= 0x00000002,	// Poly should be drawn masked.
	PF_Translucent	 	= 0x00000004,	// Poly is transparent.
	PF_NotSolid			= 0x00000008,	// Poly is not solid, doesn't block.
	PF_Environment   	= 0x00000010,	// Poly should be drawn environment mapped.
	PF_Semisolid	  	= 0x00000020,	// Poly is semi-solid = collision solid, Csg nonsolid.
	PF_Modulated 		= 0x00000040,	// Modulation transparency.
	PF_FakeBackdrop		= 0x00000080,	// Poly looks exactly like backdrop.
	PF_TwoSided			= 0x00000100,	// Poly is visible from both sides.
	PF_AutoUPan		 	= 0x00000200,	// Automatically pans in U direction.
	PF_AutoVPan 		= 0x00000400,	// Automatically pans in V direction.
	PF_NoSmooth			= 0x00000800,	// Don't smooth textures.
	PF_BigWavy 			= 0x00001000,	// Poly has a big wavy pattern in it.
	PF_SmallWavy		= 0x00002000,	// Small wavy pattern (for water/enviro reflection).
	PF_Flat				= 0x00004000,	// Flat surface.
	PF_LowShadowDetail	= 0x00008000,	// Low detaul shadows.
	PF_NoMerge			= 0x00010000,	// Don't merge poly's nodes before lighting when rendering.
	PF_CloudWavy		= 0x00020000,	// Polygon appears wavy like clouds.
	PF_DirtyShadows		= 0x00040000,	// Dirty shadows.
	PF_BrightCorners	= 0x00080000,	// Brighten convex corners.
	PF_SpecialLit		= 0x00100000,	// Only speciallit lights apply to this poly.
	PF_Gouraud			= 0x00200000,	// Gouraud shaded.
	PF_Unlit			= 0x00400000,	// Unlit.
	PF_HighShadowDetail	= 0x00800000,	// High detail shadows.
	PF_Portal			= 0x04000000,	// Portal between iZones.
	PF_Mirrored			= 0x08000000,	// Reflective surface.

	// Editor flags.
	PF_Memorized     	= 0x01000000,	// Editor: Poly is remembered.
	PF_Selected      	= 0x02000000,	// Editor: Poly is selected.
	PF_Highlighted      = 0x10000000,	// Editor: Poly is highlighted.   
	PF_FlatShaded		= 0x40000000,	// FPoly has been split by SplitPolyWithPlane.   

	// Internal.
	PF_EdProcessed 		= 0x40000000,	// FPoly was already processed in editorBuildFPolys.
	PF_EdCut       		= 0x80000000,	// FPoly has been split by SplitPolyWithPlane.  
	PF_RenderFog		= 0x40000000,	// Render with fogmapping.
	PF_Occlude			= 0x80000000,	// Occludes even if PF_NoOcclude.
	PF_RenderHint       = 0x01000000,   // Rendering optimization hint.

	// Combinations of flags.
	PF_NoOcclude		= PF_Masked | PF_Translucent | PF_Invisible | PF_Modulated,
	PF_NoEdit			= PF_Memorized | PF_Selected | PF_EdProcessed | PF_NoMerge | PF_EdCut,
	PF_NoImport			= PF_NoEdit | PF_NoMerge | PF_Memorized | PF_Selected | PF_EdProcessed | PF_EdCut,
	PF_AddLast			= PF_Semisolid | PF_NotSolid,
	PF_NoAddToBSP		= PF_EdCut | PF_EdProcessed | PF_Selected | PF_Memorized,
	PF_NoShadows		= PF_Unlit | PF_Invisible | PF_Environment | PF_FakeBackdrop,
};

//
// A database of Bsp polygons associated with a model.
//
class ENGINE_API UBspSurfs : public UDatabase
{
	DECLARE_CLASS(UBspSurfs,UDatabase,0)
	DECLARE_DB_CLASS(UBspSurfs,UDatabase,FBspSurf)

	// Constructors.

	// UObject interface.
	void ModifySelected(int UpdateMaster);
	void ModifyAllItems(int UpdateMaster);
	void ModifyItem(int Index, int UpdateMaster);
};

/*-----------------------------------------------------------------------------
	FLightMapIndex.
-----------------------------------------------------------------------------*/

//
// A shadow occlusion mask.
//
class ENGINE_API FShadowMask
{
public:
	AActor* Owner;
	TArray<BYTE> ShadowData;
	friend FArchive& operator<<( FArchive& Ar, FShadowMask& M )
	{
		return Ar << *(UObject**)&M.Owner << M.ShadowData;
	}
};

//
// Describes the mesh-based lighting applied to a Bsp poly.
//
class ENGINE_API FLightMapIndex
{
public:
	INT		DataOffset;
	INT		iLightActors;
	FVector Pan;
	FLOAT	UScale, VScale;
	INT     UClamp, VClamp;
	BYTE	UBits, VBits;
	friend FArchive& operator<<( FArchive& Ar, FLightMapIndex& I )
	{
		guard(FLightMapIndex<<);
		Ar << I.DataOffset;
		if( Ar.Ver() <= 37 )
		{
			Ar << I.Pan.X << I.Pan.Y;
			Ar << AR_INDEX(I.UClamp) << AR_INDEX(I.VClamp);
			INT MeshSpacing;
			Ar << MeshSpacing;
			I.UScale = I.VScale = MeshSpacing;
			Ar << I.iLightActors;
			BYTE MeshShift;
			Ar << MeshShift;
		}
		else
		{
			Ar << I.Pan;
			Ar << AR_INDEX(I.UClamp) << AR_INDEX(I.VClamp);
			if( Ar.Ver() < 53 )
			{
				FLOAT Scale;
				Ar << Scale;
				I.UScale = I.VScale = Scale;
			}
			else Ar << I.UScale << I.VScale;
			Ar << I.iLightActors;
		}
		return Ar;
		unguard;
	}
};

/*-----------------------------------------------------------------------------
	UPolys.
-----------------------------------------------------------------------------*/

// Results from FPoly.SplitWithPlane, describing the result of splitting
// an arbitrary FPoly with an arbitrary plane.
enum ESplitType
{
	SP_Coplanar		= 0, // Poly wasn't split, but is coplanar with plane
	SP_Front		= 1, // Poly wasn't split, but is entirely in front of plane
	SP_Back			= 2, // Poly wasn't split, but is entirely in back of plane
	SP_Split		= 3, // Poly was split into two new editor polygons
};

//
// A general-purpose polygon used by the editor.  An FPoly is a free-standing
// class which exists independently of any particular level, unlike the polys
// associated with Bsp nodes which rely on scads of other objects.  FPolys are
// used in UnrealEd for internal work, such as building the Bsp and performing
// boolean operations.
//
class ENGINE_API FPoly
{
public:
	enum {MAX_VERTICES=16}; // Maximum vertices an FPoly may have.
	enum {VERTEX_THRESHOLD=MAX_VERTICES-2}; // Threshold for splitting into two.

	FVector     Base;        	// Base point of polygon.
	FVector     Normal;			// Normal of polygon.
	FVector     TextureU;		// Texture U vector.
	FVector     TextureV;		// Texture V vector.
	FVector     Vertex[MAX_VERTICES]; // Actual vertices.
	DWORD       PolyFlags;		// FPoly & Bsp poly bit flags (PF_).
	ABrush*		Actor;			// Brush where this originated, or NULL.
	UTexture*	Texture;		// Texture map.
	FName		ItemName;		// Item name.
	INT			NumVertices;	// Number of vertices.
	INT			iLink;			// iBspSurf, or brush fpoly index of first identical polygon, or MAXWORD.
	INT			iBrushPoly;		// Index of editor solid's polygon this originated from.
	SWORD		PanU,PanV;		// Texture panning values.

	// Custom functions.
	void  Init				();
	void  Reverse			();
	void  SplitInHalf		(FPoly *OtherHalf);
	void  Transform			(const FModelCoords &Coords, const FVector &PreSubtract,const FVector &PostAdd, FLOAT Orientation);
	int   Fix				();
	int   CalcNormal		();
	int   SplitWithPlane	(const FVector &Base,const FVector &Normal,FPoly *FrontPoly,FPoly *BackPoly,int VeryPrecise) const;
	int   SplitWithNode		(const UModel *Model,INT iNode,FPoly *FrontPoly,FPoly *BackPoly,int VeryPrecise) const;
	int   SplitWithPlaneFast(const FPlane Plane,FPoly *FrontPoly,FPoly *BackPoly) const;
	int   Split				(const FVector &Normal, const FVector &Base, int NoOverflow=0 );
	int   RemoveColinears	();
	int   Finalize			(int NoError);
	int   Faces				(const FPoly &Test) const;
	FLOAT Area				();

	// Serializer.
	friend FArchive& operator<< (FArchive& Ar, FPoly &Poly)
	{
		guard(FPoly<<);
		Ar << AR_INDEX(Poly.NumVertices);
		Ar << Poly.Base << Poly.Normal << Poly.TextureU << Poly.TextureV;
		for( int i=0; i<Poly.NumVertices; i++ )
			Ar << Poly.Vertex[i];
		Ar << Poly.PolyFlags;
		Ar << *(UObject**)&Poly.Actor << Poly.Texture << Poly.ItemName;
		Ar << AR_INDEX(Poly.iLink) << AR_INDEX(Poly.iBrushPoly) << Poly.PanU << Poly.PanV;
		if( Ar.Ver()<45 )
		{
			BYTE A;
			Ar << A << A;
		}
		if( Ar.IsLoading() && (Poly.PolyFlags & PF_Masked) && (Poly.PolyFlags & PF_Translucent) )//oldver
			Poly.PolyFlags &= ~PF_Masked;
		return Ar;
		unguard;
	}

	// Inlines.
	int IsBackfaced( const FVector &Point ) const
		{return ((Point-Base) | Normal) < 0.0;}
	int IsCoplanar( const FPoly &Test ) const
		{return Abs((Base - Test.Base)|Normal)<0.01 && Abs(Normal|Test.Normal)>0.9999;}
};

//
// List of FPolys.
//
class ENGINE_API UPolys : public UDatabase
{
	DECLARE_CLASS(UPolys,UDatabase,0)
	DECLARE_DB_CLASS(UPolys,UDatabase,FPoly)

	// Constructors.

	// UObject interface.
	void Export( FOutputDevice& Out, const char* FileType, int Indent );
};

/*-----------------------------------------------------------------------------
	UVectors.
-----------------------------------------------------------------------------*/

//
// A table of floating point vectors.  Used within levels to store all points
// and vectors in the world.
//
class ENGINE_API UVectors : public UDatabase
{
	DECLARE_CLASS(UVectors,UDatabase,0)
	DECLARE_DB_CLASS(UVectors,UDatabase,FVector)

	// Constructors.
};

/*-----------------------------------------------------------------------------
	UVerts.
-----------------------------------------------------------------------------*/

//
// One vertex associated with a Bsp node's polygon.  Contains a vertex index
// into the level's FPoints table, and a unique number which is common to all
// other sides in the level which are cospatial with this side.
//
class FVert
{
public:
	// Variables.
	INT 	pVertex;	// Index of vertex.
	INT		iSide;		// If shared, index of unique side. Otherwise INDEX_NONE.

	// Functions.
	friend FArchive& operator<< (FArchive &Ar, FVert &Vert)
	{
		guard(FVert<<);
		return Ar << AR_INDEX(Vert.pVertex) << AR_INDEX(Vert.iSide);
		unguard;
	}
};

//
// Vertex pool object, containing all point lists referenced by Bsp polygons,
// as well as connectivity information linking sides of adjacent polys.
//
class ENGINE_API UVerts : public UDatabase
{
	DECLARE_CLASS(UVerts,UDatabase,0)
	DECLARE_DB_CLASS(UVerts,UDatabase,FVert)

	// Variables.
	INT NumSharedSides; // Number of unique iSideIndex's.

	// Constructors.

	// UObject interface.
	void Serialize(FArchive& Ar)
	{
		guard(UVerts::Serialize);
		UDatabase::Serialize(Ar);
		Ar << AR_INDEX(NumSharedSides);
		unguardobj;
	}
};

/*-----------------------------------------------------------------------------
	Bit arrays.
-----------------------------------------------------------------------------*/

//
// A bit array.
//
class ENGINE_API UBitArray : public UObject
{
	DECLARE_CLASS_WITHOUT_CONSTRUCT(UBitArray,UObject,0)
	NO_DEFAULT_CONSTRUCTOR(UBitArray)

	// Variables.
	TArray<DWORD> Data;
	DWORD NumBits;

	// Constructor.
	UBitArray( DWORD InNumBits )
	:	NumBits( InNumBits )
	{
		guard(UBitArray::UBitArray);
		Data.Add( (InNumBits+31)/32 );
		unguard;
	}

	// UObject interface.
	void Serialize( FArchive& Ar );

	// UBitArray interface.
	UBOOL Get( DWORD i )
	{
		check(i<(DWORD)NumBits);
		return (Data(i/32) & (1 << (i&31))) != 0;
	}
	void Set( DWORD i, UBOOL Value )
	{
		check(i<(DWORD)NumBits);
		if( Value ) Data(i/32) |= 1 << (i&31);
		else        Data(i/32) &= ~(1 << (i&31));
	}
};

//
// An nxn symmetric bit array.
//
class ENGINE_API UBitMatrix : public UBitArray
{
	DECLARE_CLASS_WITHOUT_CONSTRUCT(UBitMatrix,UBitArray,0)
	NO_DEFAULT_CONSTRUCTOR(UBitMatrix)

	// Variables.
	DWORD Side;

	// Constructor.
	UBitMatrix( DWORD InSide )
	:	UBitArray( InSide * (InSide + 1)/2 )
	,	Side(InSide)
	{}

	// UObject interface.
	void Serialize( FArchive& Ar )
	{
		guard(UBitMatrix::Serialize);
		UBitArray::Serialize(Ar);
		Ar << AR_INDEX(Side);
		unguardobj;
	}

	// UBitMatrix interface.
	UBOOL Get( DWORD i, DWORD j )
	{
		check(i<Side&&j<Side);
		return UBitArray::Get( (i<=j) ? (i + j*(j+1)/2) : (j + i*(i+1)/2) );
	}
	void Set( DWORD i, DWORD j, UBOOL Value )
	{
		check(i<Side&&j<Side);
		UBitArray::Set( (i<=j) ? (i + j*(j+1)/2) : (j + i*(i+1)/2), Value );
	}
};

/*----------------------------------------------------------------------------
	The End.
----------------------------------------------------------------------------*/
